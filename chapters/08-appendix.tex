\chapter{Appendix}

\section{\label{sec:sourcecode}Source codes}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{Cstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{green}\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{red}\ttfamily,
    basicstyle=\ttfamily,
    morecomment=[l][\color{magenta}\ttfamily]{\#},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{language=C,style=Cstyle,
literate=%
    *{0}{{{\color{red}0}}}1
    {1}{{{\color{red}1}}}1
    {2}{{{\color{red}2}}}1
    {3}{{{\color{red}3}}}1
    {4}{{{\color{red}4}}}1
    {5}{{{\color{red}5}}}1
    {6}{{{\color{red}6}}}1
    {7}{{{\color{red}7}}}1
    {8}{{{\color{red}8}}}1
    {9}{{{\color{red}9}}}1}
\subsection{FIR-filter - ANSI-C}
\begin{lstlisting}[caption=FIR-filter implemented in C]
#include <stdio.h>
#define DEPTH 4

int FIRFilter ( int in, int coeff[], int sr[]){
  int j, temp;
   for(j=DEPTH-1; j >= 1; j-=1 ){
     sr[j] = sr[j-1];
   }
  sr[0] = in;
  if (sr[DEPTH-1] == 0)
    return 0;
  else {
    temp = 0;
    for (j = 0; j < DEPTH; j++){
        temp += sr[j] * coeff[j];
    }
    return temp;
  }
}

int main(int inData){
  int sr[DEPTH];
	int products[DEPTH];
  int coeff[DEPTH] = {1,2,3,4};
  int dataOut = 0;
	int i;
  for (i = 0; i <= DEPTH; i++){
      products[i] = FIRFilterStreaming (inData, coeff, sr);
      dataOut += products[i];
  }
  return dataOut;
}
\end{lstlisting}
\subsection{FIR-filter - Verilog}

\subsection{SAP-1 architecture - ANSI-C}
\begin{lstlisting}[caption=SAP-1 architecture implemented in C]
#include <stdbool.h>

typedef enum {T1, T2, T3, T4, T5, T6} states_t;
typedef enum {LDA = 0b0000, ADD = 0b0001, SUB = 0b0010, OUT = 0b1110, HLT = 0b1111} opcodes_t;

states_t state;
opcodes_t opcode;
bool cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n; 
 
unsigned char wbus = 0x00;
 
signed char accumulator_reg;
signed char registerb_reg;
unsigned char memoryAddressRegister_reg;
unsigned char ram[16];
 
int main (int arst) {
	while(1){
		//Reset to default values
		if(arst) {
			state = T1;
			{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,0,0,1,1};
			wbus = 0x00;
			accumulator_reg = 0x00;
			registerb_reg = 0x00;
			memoryAddressRegister_reg = 0x00;
			ram = {0x00};
		}
		
		ControllerSequence();
		ProgramCounter();
		InstructionRegister();
		MemoryAddressRegister();
		Ram();
		BRegister();
		AccumulatorA();
		AddSub();
		return OutputRegister();
		state++;
	}
}

void AccumulatorA() {
	if (ea) {
		wbus = accumulator_reg;
	}
	else if (!la_n) {
		accumulator_reg = wbus;
	}
}

void ProgramCounter() {
	if(arst || wBusLower == 15) {
		wBusLower = 0;
	}
	else if(cp) {
		wBusLower++;
	}
}

void MemoryAddressRegister() {
	if(!lm_n) {
		memoryAddressRegister_reg = wbus & 0b00001111;
	}
}

void AddSub() {
	if(eu){
		if(su){wbus = accumulator_reg + ~registerb_reg;}
		else if (!su) {wbus = accumulator_reg + registerb_reg;}
	}
}

void Ram() {
	if (!ce_n) {
		wbus = ram[memoryAddressRegister_reg];
	}
}

void ControllerSequence() {
	switch(state) {
	case T1:
		{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,1,0,1,1,1,1,0,0,0,1,1};
		break;
	case T2:
		{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {1,0,1,1,1,1,1,0,0,0,1,1};
		break;
	case T3:
		{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,0,0,1,1,0,0,0,1,1};
		break;
	case T4:
		if(opcode == LDA || opcode == ADD || opcode == SUB) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,0,1,1,0,1,0,0,0,1,1};}
		else if(opcode == OUT) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,0,0,0,0,1,0};}
		else {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,0,0,1,1};}
		break;
	case T5:
		if(opcode == LDA) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,0,1,1,0,0,0,0,1,1};}
		else if(opcode == ADD || opcode == SUB) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,0,1,1,1,0,0,0,0,1};}
		else {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,0,0,1,1};}
		break;
	case T6:
		if(opcode == ADD) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,0,1,1,1};}
		else if(opcode == SUB) {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,1,1,1,1};}
		else {{cp,ep,lm_n,ce_n,li_n,ei_n,la_n,ea,su,eu,lb_n,lo_n} = {0,0,1,1,1,1,1,0,0,0,1,1};}
		break;
	}
}

void BRegister() {
	if (!lb_n) {
		registerb_reg = wbus;
	}
}

void InstructionRegister() {
	if (!li_n) {
		opcode = wbus >>> 4;
	}
}

char OutputRegister() {
	if(ea) {
		return accumulator_reg;
	}
	else {
		return NULL;
	}
}
\end{lstlisting}
\subsection{SAP-1 architecture - Verilog}
