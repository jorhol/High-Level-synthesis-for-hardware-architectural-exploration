\chapter{Conclusion}
\label{chp:conclusion} 

\section{Future work}
\label{sec:futurework} 
This report has presented a specification of a framework that can be used for architectural exploration of digital hardware. Due to multiple time-consuming problems encountered along the way, described in detail in \cref{sec:encprob}, no results from comparison between hand-written Verilog and \gls{hls} generated Verilog is presented. Also, the goals of the project, set in the beginning of the working period, might have been slightly exaggerated.The primary objectives of this project, namely to create an initial framework for hardware architectural exploration using \gls{hls}, were not met.

If this project should be extended into a master thesis or a project at a later stage, the following issues needs to be handled:
\begin{enumerate}\label{enum:futworkprob}
    \item \label{item:futworkprob}The Clang frontend in LLVM, used by LegUP for compilation of the C-source code, needs to be altered so that the list of input variables and return values in the \textit{main}-function of the C program can be of other formats than the standard \textit{int main(int argc, char *argv[])}.
    \item Pointers in the C program needs to be transformed into signals instead of a memory location inside the memory controller. As there is only one module in the output Verilog, no point-to analysis is needed to decide what module the pointed variable will be used. This will eliminate the need for the memory controller and global \gls{ram}s.
    \item The memory controller module, as well as all other unused, \gls{fpga} specific modules, need to be removed from the Verilog generation. Theses modules are not needed when there is no hybrid-flow and pointers no longer is stored in global memory. Technically, the most important task is to ensure that the modules are not instantiated in the top module, but having multiple unused modules declared in the Verilog code clogs up the file with unnecessary lines, making it harder to detect actually important parts.
\end{enumerate}

\textbf{Possible solutions}

\noindent
There are two possible approaches in order to fix these problems:
\begin{itemize}
\item Post-processing of the Verilog generated by LegUp in order to remove unwanted code and adapt the code into a format suitable for synthesis towards an \gls{asic} implementation.
\item Pre-processing, i.e. altering the LegUp and \gls{llvm} libraries that are used for compilation of the source code and Verilog generation so that the output Verilog are synthesizable to \gls{asic} applications.
\end{itemize}

The post-processing solution is clearly the simplest alternative, as it only requires a parser that can remove or reformat code output. This alternative is however very uncertain with respect to the quality of results. The question is whether the output Verilog contains enough information to transform it into a usable Verilog code.

As an example, we can use the code described in \cref{lst:exampleCProgram} as a base. The output Verilog declares the input variables inDataA and inDataB differently, as inDataA is declared as an int while inDataB is declared as a char-pointer. The output gives:
\lstset{language=Verilog, style=Verilogstyle}
\begin{lstlisting}
input [31:0] arg_inDataA;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] arg_inDataB;
\end{lstlisting}
Later in the Verilog code, the signal inDataA is used as a normal variable, but each time inDataB is used, the value of inDataB is assigned to memory\_controller\_add-ress\_a, and in the next cycle, the data is sent from the memory controller to the input memory\_controller\_out\_b of the main module. In this case, the post-processer needs to change the declaration of \textit{inDataB} to be a signal in the circuit, rather than a connection to the memory controller. 
\begin{lstlisting}
input [31:0] arg_inDataA;
input [31:0] arg_inDataB;
\end{lstlisting}
The post-processor also needs to change the part of the code where the value of inDataB, gathered from the memory controller, is used in operations inside the main module. For instance, the following code snippet in the generated Verilog, assigning the value of inDataB from the memory controller (the commented line refers to the LLVMs \gls{ir}):
\begin{lstlisting}
	/*   %36 = load i8** %inDataB, align 4*/
	main_35_36 = memory_controller_out_a[`MEMORY_CONTROLLER_ADDR_SIZE-1:0];
\end{lstlisting}
should be changed to:
\begin{lstlisting}
	/*   %36 = load i8** %inDataB, align 4*/
	main_35_36 = arg_inDataB[31:0];
\end{lstlisting}
This simple example shows what needs to be changed in order to get the correct functionality. This is however not the only part that should be changed. Each access to a global memory takes two clock cycles, meaning that the generated \gls{fsm} takes account for this delay. The delay will have to be eliminated in order to get the best performance out of the circuit. If it is not removed and the user is not aware of the delay, input data might be lost.

The outcome of this is that the parser needs to account for a large amount of potential alterations in the output Verilog, making it a complex task to get everything correct.

The alternative of altering the LegUp and \gls{llvm} libraries, offers much greater opportunities for you to get a functional and correct Verilog output. The downside of this alternative is that the LegUp libraries are quite large, and searching, understanding and altering large parts of the code can be time-consuming. 

A possible solution to the problem mentioned in \cref{item:futworkprob} in \cref{enum:futworkprob} has been found. By adding the flag \textit{-ffreestanding} to the variable CLANG\_FLAG in the file Makefile.config of LegUp, the clang compiler frontend of LLVM will consider the C code to contain a freestanding, not a hosted, environment, and therefore not caring about what inputs and return values the \textit{main}-function has. This will allow multiple input arguments of any type. You will still be limited to one return variable, as C not supports multiple return values. The return value can be a struct, but due to the limited support for structs, it is not likely that LegUp splits the variables in the struct into multiple output signals in the generated Verilog. The alternative is to use pointers as input arguments, making it possible to get output variables as pass-by-reference variables. This will probably require major alterations to the LegUp libraries.   

When removing the memory controller, all 

One of the questions raised in the motivation section in the introduction chapter was whether the incorporation of Nordic Semiconductor's \gls{ddvc} into the Verilog generating libraries of LegUp would reduce the generated overhead. As this was not a objective of this project, this extension should be performed in an continuation of the project.

When setting the constraint \textit{INFERRED\_RAMS}, as described in \cref{subsec:hlsreqconst}, the support for structs are lost. This constraint is needed since altsyncram modules are not supported by non-Altera devices, but the support for structs are a strength in \gls{hll}-languages that can be useful in many cases when describing the circuit functionality in the C-code before \gls{hls}. According to \cite{legupconst} this lack of struct-support is due to that there is no byte-enable support in the inferred RAMs. Byte-enable means being able to write a single byte (8 bits) to the \gls{ram} instead of the full 16, 32 or 64-bit word. To retrieve the support for structs, a generic \gls{ram} module with byte-enable support needs to be implemented in Verilog and incorporated into the LegUp libraries as an alternative to the inferred generic \gls{ram}s and the altsyncram. 