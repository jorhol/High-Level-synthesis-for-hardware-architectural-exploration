\chapter{Future work}
\label{chp:futurework} 
This report has presented a specification of a framework that can be used for architectural exploration of digital hardware. Due to multiple time-consuming problems encountered along the way, described in detail in section \ref{sec:encprob}, no results from comparison between hand-written Verilog and \gls{hls} generated Verilog is presented. Also, the goals of the project, set in the beginning of the working period, might have been slightly exaggerated.The primary objectives of this project, namely to create an initial framework for hardware architectural exploration using \gls{hls}, were not met.

If this project should be extended into a master thesis or a project at a later stage, the following issues needs to be handled:
\begin{enumerate}\label{enum:futworkprob}
    \item \label{item:futworkprob}The Clang frontend in LLVM, used by LegUP for compilation of the C-source code, needs to be altered so that the list of input variables and return values in the \textit{main}-function of the C program can be of other formats than the standard \textit{int main(int argc, char *argv[])}.
    \item Pointers in the C program needs to be transformed into signals instead of a memory location inside the memory controller. As there is only one module in the output Verilog, no point-to analysis is needed to decide what module the pointed variable will be used. This will eliminate the need for the memory controller and global \gls{ram}s.
    \item The memory controller module, as well as all other unused, \gls{fpga} specific modules, need to be removed from the Verilog generation. Theses modules are not needed when there is no hybrid-flow and pointers no longer is stored in global memory. Technically, the most important task is to ensure that the modules are not instantiated in the top module, but having multiple unused modules declared in the Verilog code clogs up the file with unnecessary lines, making it harder to detect actually important parts.
\end{enumerate}

\textbf{Possible solutions}

\noindent
There are two possible approaches in order to fix these problems:
\begin{itemize}
\item Post-processing of the Verilog generated by LegUp in order to remove unwanted code and adapt the code into a format suitable for synthesis towards an \gls{asic} implementation.
\item Pre-processing, i.e. altering the LegUp and \gls{llvm} libraries that are used for compilation of the source code and Verilog generation so that the output Verilog are synthesizable to \gls{asic} applications.
\end{itemize}



The post-processing solution is clearly the simplest alternative, as it only requires a parser that can remove or reformat code output. This alternative is however very uncertain with respect to the quality of results. The question is whether the output Verilog contains enough information to transform it into a usable Verilog code.
The alternative of altering the LegUp and \gls{llvm} libraries, offers much greater opportunities for you to get a functional and correct Verilog output. The downside of this alternative is that the LegUp libraries are quite large, and searching, understanding and altering large parts of the code can be time-consuming. 

A possible solution to the problem mentioned in \cref{item:futworkprob} in \cref{enum:futworkprob} has been found. By adding the flag \textit{-ffreestanding} to the variable CLANG\_FLAG in the file Makefile.config of LegUp, the clang compiler frontend of LLVM will consider the C code to contain a freestanding, not a hosted, environment, and therefore not caring about what inputs and return values the \textit{main}-function has. This will allow multiple input arguments of any type. You will still be limited to one return variable, as C not suports multiple return values. The return value can be a struct, but due to the limited support for structs, it is not likely that LegUp splits the variables in the struct into multiple output signals in the generated Verilog. The alternative is to use pointers as input arguments, making it possible to get output variables as pass-by-reference variables. This will probably require major alterations to the LegUp libraries.   

When removing the memory controller, all 

Some other 



One of the questions raised in the motivation section in the introduction chapter was whether the incorporation of Nordic Semiconductor's \gls{ddvc} into the Verilog generating libraries of LegUp would reduce the generated overhead. As this was not a objective of this project, this extension should be performed in an continuatuon of the project.

When setting the constraint \textit{INFERRED\_RAMS}, as described in \cref{subsec:hlsreqconst}, the support for structs are lost. This constraint is needed since altsyncram modules are not supported by non-Altera devices, but the support for structs are a strength in \gls{hll}-languages that can be useful in many cases when describing the circuit functionality in the C-code before \gls{hls}. According to \cite{legupconst} this lack of struct-support is due to that there is no byte-enable support in the inferred RAMs. Byte-enable means being able to write a single byte (8 bits) to the \gls{ram} instead of the full 16, 32 or 64-bit word. To retrieve the support for structs, a generic \gls{ram} module with byte-enable support needs to be implemented in Verilog and incorporated into the LegUp libraries as an alternative to the inferred generic \gls{ram}s and the altsyncram. 